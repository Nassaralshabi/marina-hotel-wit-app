<!DOCTYPE html>
<html>
<head>
<script type="text/javascript">
  // This is a CodeSandbox injection script that's used to
  // add navigation and inspector functionality to the preview
  (function () {
    // 1) Get the <script> tag that's currently running:
    var me = document.currentScript;

    // 2) Create the blockingâ€style <script> to load:
    var script = document.createElement("script");
    script.src = "https://codesandbox.io/p/preview-protocol.js";

    // By default a dynamicallyâ€inserted <script> is async=true.
    // Turn async off to make it behave like a normal blocking <script>:
    script.async = false;
    // (Do NOT set defer.)

    // 3) Insert it immediately after the current <script>:
    me.parentNode.insertBefore(script, me);
  })();

  const isIFramePreview = window.top !== window.self;

  // Only run this script in editor context
  if (isIFramePreview) {
    // This script is used to enable Chrome DevTools functionality
    (function () {
      var script = document.createElement("script");
      script.src =
        "https://codesandbox.io/p/chrome-devtool/protocol/index.js";

      script.onload = () => {
        const devtoolProtocol = window.chobitsu;
        if (devtoolProtocol) {
          window.addEventListener("message", (event) => {
            const { type, data } = event.data;

            if (type === "FROM_DEVTOOL") {
              devtoolProtocol.sendRawMessage(data);
            }
          });

          devtoolProtocol.setOnMessage((data) => {
            if (data.includes('"id":"tmp')) {
              return;
            }

            window.parent.postMessage({ type: "TO_DEVTOOL", data }, "*");
          });

          devtoolProtocol.sendRawMessage(
            `{"id":5,"method":"Runtime.enable","params":{}}`
          );
        }        
      }

      (document.head || document.documentElement).prepend(script);
    })();
  }

  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
    let nextID = 0;
    let hook = (__REACT_DEVTOOLS_GLOBAL_HOOK__ = {
      renderers: new Map(),
      supportsFiber: true,
      inject: (renderer) => {
        const id = nextID++;
        hook.renderers.set(id, renderer);
        return id;
      },
      onScheduleFiberRoot() {},
      onCommitFiberRoot() {},
      onCommitFiberUnmount() {},
    });
  }

  document.currentScript.remove();
</script>
    <meta charset="UTF-8">
    <title>Ø¥Ù†Ø´Ø§Ø¡ Ø£ÙŠÙ‚ÙˆÙ†Ø© ÙÙˆØ±ÙŠØ©</title>
</head>
<body>
    <canvas id="canvas" width="192" height="192" style="border: 1px solid #ddd;"></canvas>
    <br><br>
    <button onclick="downloadIcon()">ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©</button>
    
    <script>
        // Ø¥Ù†Ø´Ø§Ø¡ Ø£ÙŠÙ‚ÙˆÙ†Ø© ÙÙˆØ±ÙŠØ©
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Ø®Ù„ÙÙŠØ© Ø²Ø±Ù‚Ø§Ø¡
        const gradient = ctx.createLinearGradient(0, 0, 192, 192);
        gradient.addColorStop(0, '#667eea');
        gradient.addColorStop(1, '#764ba2');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 192, 192);
        
        // Ø±Ø³Ù… Ø£ÙŠÙ‚ÙˆÙ†Ø© ÙÙ†Ø¯Ù‚
        ctx.fillStyle = 'white';
        ctx.font = 'bold 96px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ğŸ¨', 96, 96);
        
        function downloadIcon() {
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'icon-192x192.png';
                link.click();
                URL.revokeObjectURL(url);
                
                // Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø£Ø­Ø¬Ø§Ù…
                createAllSizes();
            });
        }
        
        function createAllSizes() {
            const sizes = [72, 96, 128, 144, 152, 384, 512];
            
            sizes.forEach((size, index) => {
                setTimeout(() => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = size;
                    tempCanvas.height = size;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Ø±Ø³Ù… Ù†ÙØ³ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø¨Ø­Ø¬Ù… Ù…Ø®ØªÙ„Ù
                    const tempGradient = tempCtx.createLinearGradient(0, 0, size, size);
                    tempGradient.addColorStop(0, '#667eea');
                    tempGradient.addColorStop(1, '#764ba2');
                    tempCtx.fillStyle = tempGradient;
                    tempCtx.fillRect(0, 0, size, size);
                    
                    tempCtx.fillStyle = 'white';
                    tempCtx.font = `bold ${size * 0.5}px Arial`;
                    tempCtx.textAlign = 'center';
                    tempCtx.textBaseline = 'middle';
                    tempCtx.fillText('ğŸ¨', size / 2, size / 2);
                    
                    tempCanvas.toBlob(function(blob) {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `icon-${size}x${size}.png`;
                        link.click();
                        URL.revokeObjectURL(url);
                    });
                }, index * 200);
            });
            
            alert('Ø³ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹!\nØ¶Ø¹ Ø§Ù„Ù…Ù„ÙØ§Øª ÙÙŠ Ù…Ø¬Ù„Ø¯: assets/icons/');
        }
        
        // ØªØ­Ù…ÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù†Ø¯ ÙØªØ­ Ø§Ù„ØµÙØ­Ø©
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (confirm('Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª Ø§Ù„Ø¢Ù†ØŸ')) {
                    downloadIcon();
                }
            }, 1000);
        });
    </script>
</body>
</html>